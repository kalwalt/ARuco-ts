!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r=e();for(var o in r)("object"==typeof exports?exports:t)[o]=r[o]}}(this,(()=>(()=>{"use strict";var t,e,r,o,s={d:(t,e)=>{for(var r in e)s.o(e,r)&&!s.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},n={};s.r(n),s.d(n,{ARuco:()=>e,CV:()=>t,POS:()=>o,SVD:()=>r});class i{width;height;data;constructor(t=0,e=0,r=[]){this.width=t,this.height=e,this.data=r}}class a{color;next;constructor(){this.color=0,this.next=null}}class h{static grayscale(t){let e=t.data,r=[],o=new i,s=e.length,n=0,a=0;for(;n<s;n+=4)r[a++]=.299*e[n]+.587*e[n+1]+.114*e[n+2]+.5&255;return o.width=t.width,o.height=t.height,o.data=r,o}static threshold(t,e,r){let o,s=t.data,n=e.data,i=s.length,a=[];for(o=0;o<256;++o)a[o]=o<=r?0:255;for(o=0;o<i;++o)n[o]=a[s[o]];return e.width=t.width,e.height=t.height,e}static adaptiveThreshold(t,e,r,o){let s,n=t.data,i=e.data,a=n.length,l=[];for(h.stackBoxBlur(t,e,r),s=0;s<768;++s)l[s]=s-255<=-o?255:0;for(s=0;s<a;++s)i[s]=l[n[s]-i[s]+255];return e.width=t.width,e.height=t.height,e}static otsu(t){let e,r,o,s=t.data,n=s.length,i=[],a=0,h=0,l=0,d=0,c=0,u=0;for(o=0;o<256;++o)i[o]=0;for(o=0;o<n;++o)i[s[o]]++;for(o=0;o<256;++o)h+=i[o]*o;for(o=0;o<256;++o)if(d+=i[o],0!==d){if(c=n-d,0===c)break;l+=i[o]*o,e=l/d-(h-l)/c,r=d*c*e*e,r>u&&(u=r,a=o)}return a}static stackBoxBlurMult=[1,171,205,293,57,373,79,137,241,27,391,357,41,19,283,265];static stackBoxBlurShift=[0,9,10,11,9,12,10,11,12,9,13,13,10,9,13,13];static stackBoxBlur(t,e,r){let o,s,n,i,l,d,c,u,f,x,g=t.data,m=e.data,y=t.height,v=t.width,p=y-1,w=v-1,b=r+r+1,M=r+1,_=h.stackBoxBlurMult[r],P=h.stackBoxBlurShift[r];for(o=s=new a,x=1;x<b;++x)o=o.next=new a;for(o.next=s,l=0,f=0;f<y;++f){for(d=l,n=g[l],i=M*n,o=s,x=0;x<M;++x)o.color=n,o=o.next;for(x=1;x<M;++x)o.color=g[l+x],i+=o.color,o=o.next;for(o=s,u=0;u<v;++u)m[l++]=i*_>>>P,c=u+M,c=d+(c<w?c:w),i-=o.color-g[c],o.color=g[c],o=o.next}for(u=0;u<v;++u){for(l=u,d=l+v,n=m[l],i=M*n,o=s,x=0;x<M;++x)o.color=n,o=o.next;for(x=1;x<M;++x)o.color=m[d],i+=o.color,o=o.next,d+=v;for(o=s,f=0;f<y;++f)m[l]=i*_>>>P,c=f+M,c=u+(c<p?c:p)*v,i-=o.color-m[c],o.color=m[c],o=o.next,l+=v}return e}static gaussianBlur(t,e,r,o){var s=h.gaussianKernel(o);return e.width=t.width,e.height=t.height,r.width=t.width,r.height=t.height,h.gaussianBlurFilter(t,r,s,!0),h.gaussianBlurFilter(r,e,s,!1),e}static gaussianBlurFilter(t,e,r,o){let s,n,i,a,h,l=t.data,d=e.data,c=t.height,u=t.width,f=0,x=r.length>>1;for(i=0;i<c;++i)for(a=0;a<u;++a){for(n=0,h=-x;h<=x;++h)o?(s=f+h,(a+h<0||a+h>=u)&&(s=f)):(s=f+h*u,(i+h<0||i+h>=c)&&(s=f)),n+=r[x+h]*l[s];d[f++]=o?n:n+.5&255}return e}static gaussianKernel(t){let e,r,o,s,n,i,a=[];if(t<=7&&t%2==1)a=[[1],[.25,.5,.25],[.0625,.25,.375,.25,.0625],[.03125,.109375,.21875,.28125,.21875,.109375,.03125]][t>>1];else{for(e=.5*(t-1),r=.8+.3*(e-1),o=-.5/(r*r),s=0,i=0;i<t;++i)n=i-e,s+=a[i]=Math.exp(o*n*n);for(s=1/s,i=0;i<t;++i)a[i]*=s}return a}static findContours(t,e){let r,o,s,n,i,a,l,d,c,u=t.width,f=t.height,x=[];for(r=h.binaryBorder(t,e),o=h.neighborhoodDeltas(u+2),s=u+3,i=1,d=0;d<f;++d,s+=2)for(c=0;c<u;++c,++s)n=r[s],0!==n&&(a=l=!1,1===n&&0===r[s-1]?a=!0:n>=1&&0===r[s+1]&&(l=!0),(a||l)&&(++i,x.push(h.borderFollowing(r,s,i,{x:c,y:d},l,o))));return x}static borderFollowing(t,e,r,o,s,n){let i,a,l,d,c,u,f=[];f.hole=s,d=c=s?0:4;do{if(d=d-1&7,i=e+n[d],0!==t[i])break}while(d!==c);if(d===c)t[e]=-r,f.push({x:o.x,y:o.y});else for(a=e,u=4^d;;){c=d;do{l=a+n[++d]}while(0===t[l]);if(d&=7,d-1>>>0<c>>>0?t[a]=-r:1===t[a]&&(t[a]=r),f.push({x:o.x,y:o.y}),u=d,o.x+=h.neighborhood[d][0],o.y+=h.neighborhood[d][1],l===e&&a===i)break;a=l,d=d+4&7}return f}static neighborhood=[[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[-1,1],[0,1],[1,1]];static neighborhoodDeltas(t){let e=[],r=h.neighborhood.length,o=0;for(;o<r;++o)e[o]=h.neighborhood[o][0]+h.neighborhood[o][1]*t;return e.concat(e)}static approxPolyDP(t,e){let r,o,s,n,i,a,h,l,d,c,u,f={start_index:0,end_index:0},x={start_index:0,end_index:0},g=[],m=[],y=t.length;for(e*=e,u=0,d=0;d<3;++d)for(i=0,u=(u+x.start_index)%y,o=t[u],++u===y&&(u=0),c=1;c<y;++c)r=t[u],++u===y&&(u=0),h=r.x-o.x,l=r.y-o.y,n=h*h+l*l,n>i&&(i=n,x.start_index=c);for(i<=e?g.push({x:o.x,y:o.y}):(f.start_index=u,f.end_index=x.start_index+=f.start_index,x.start_index-=x.start_index>=y?y:0,x.end_index=f.start_index,x.end_index<x.start_index&&(x.end_index+=y),m.push({start_index:x.start_index,end_index:x.end_index}),m.push({start_index:f.start_index,end_index:f.end_index}));0!==m.length;){if(f=m.pop(),s=t[f.end_index%y],o=t[u=f.start_index%y],++u===y&&(u=0),f.end_index<=f.start_index+1)a=!0;else{for(i=0,h=s.x-o.x,l=s.y-o.y,d=f.start_index+1;d<f.end_index;++d)r=t[u],++u===y&&(u=0),n=Math.abs((r.y-o.y)*h-(r.x-o.x)*l),n>i&&(i=n,x.start_index=d);a=i*i<=e*(h*h+l*l)}a?g.push({x:o.x,y:o.y}):(x.end_index=f.end_index,f.end_index=x.start_index,m.push({start_index:x.start_index,end_index:x.end_index}),m.push({start_index:f.start_index,end_index:f.end_index}))}return g}static warp(t,e,r,o){let s,n,i,a,l,d,c,u,f,x,g,m,y,v,p,w,b,M,_,P,B,k,q,S=t.data,C=e.data,L=t.width,N=t.height,T=0;for(y=h.getPerspectiveTransform(r,o-1),v=y[8],p=y[2],w=y[5],k=0;k<o;++k)for(v+=y[7],p+=y[1],w+=y[4],b=v,M=p,_=w,q=0;q<o;++q)b+=y[6],M+=y[0],_+=y[3],P=M/b,B=_/b,s=P>>>0,n=s===L-1?s:s+1,i=P-s,a=1-i,l=B>>>0,d=l===N-1?l:l+1,c=B-l,u=1-c,f=x=l*L,g=m=d*L,C[T++]=u*(a*S[f+s]+i*S[x+n])+c*(a*S[g+s]+i*S[m+n])&255;return e.width=o,e.height=o,e}static getPerspectiveTransform(t,e){let r=h.square2quad(t);return r[0]/=e,r[1]/=e,r[3]/=e,r[4]/=e,r[6]/=e,r[7]/=e,r}static square2quad(t){let e,r,o,s,n,i,a,h=[];return e=t[0].x-t[1].x+t[2].x-t[3].x,r=t[0].y-t[1].y+t[2].y-t[3].y,0===e&&0===r?(h[0]=t[1].x-t[0].x,h[1]=t[2].x-t[1].x,h[2]=t[0].x,h[3]=t[1].y-t[0].y,h[4]=t[2].y-t[1].y,h[5]=t[0].y,h[6]=0,h[7]=0,h[8]=1):(o=t[1].x-t[2].x,s=t[3].x-t[2].x,n=t[1].y-t[2].y,i=t[3].y-t[2].y,a=o*i-s*n,h[6]=(e*i-s*r)/a,h[7]=(o*r-e*n)/a,h[8]=1,h[0]=t[1].x-t[0].x+h[6]*t[1].x,h[1]=t[3].x-t[0].x+h[7]*t[3].x,h[2]=t[0].x,h[3]=t[1].y-t[0].y+h[6]*t[1].y,h[4]=t[3].y-t[0].y+h[7]*t[3].y,h[5]=t[0].y),h}static isContourConvex(t){let e,r,o,s,n,i,a,h,l=0,d=!0,c=t.length,u=0,f=0;for(r=t[c-1],e=t[0],n=e.x-r.x,i=e.y-r.y;u<c;++u){if(++f===c&&(f=0),r=e,e=t[f],a=e.x-r.x,h=e.y-r.y,o=a*i,s=h*n,l|=s>o?1:s<o?2:3,3===l){d=!1;break}n=a,i=h}return d}static perimeter(t){let e,r,o=t.length,s=0,n=o-1,i=0;for(;s<o;n=s++)e=t[s].x-t[n].x,r=t[s].y-t[n].y,i+=Math.sqrt(e*e+r*r);return i}static minEdgeLength(t){let e,r,o,s=t.length,n=0,i=s-1,a=1/0;for(;n<s;i=n++)r=t[n].x-t[i].x,o=t[n].y-t[i].y,e=r*r+o*o,e<a&&(a=e);return Math.sqrt(a)}static countNonZero(t,e){let r,o,s=t.data,n=e.height,i=e.width,a=e.x+e.y*t.width,h=t.width-i,l=0;for(r=0;r<n;++r){for(o=0;o<i;++o)0!==s[a++]&&++l;a+=h}return l}static binaryBorder(t,e){let r,o,s=t.data,n=t.height,i=t.width,a=0,h=0;for(o=-2;o<i;++o)e[h++]=0;for(r=0;r<n;++r){for(e[h++]=0,o=0;o<i;++o)e[h++]=0===s[a++]?0:1;e[h++]=0}for(o=-2;o<i;++o)e[h++]=0;return e}}class l{id;corners;constructor(t,e){this.id=t,this.corners=e}}class d{grey;thres;homography;binary;contours;polys;candidates;constructor(){this.grey=new i,this.thres=new i,this.homography=new i,this.binary=[],this.contours=[],this.polys=[],this.candidates=[]}detect(t){return this.grey=h.grayscale(t),h.adaptiveThreshold(this.grey,this.thres,2,7),this.contours=h.findContours(this.thres,this.binary),this.candidates=this.findCandidates(this.contours,.2*t.width,.05,10),this.candidates=this.clockwiseCorners(this.candidates),this.candidates=this.notTooNear(this.candidates,10),this.findMarkers(this.grey,this.candidates,49)}findCandidates(t,e,r,o){let s,n,i,a=[],l=t.length;for(this.polys=[],i=0;i<l;++i)s=t[i],s.length>=e&&(n=h.approxPolyDP(s,s.length*r),this.polys.push(n),4===n.length&&h.isContourConvex(n)&&h.minEdgeLength(n)>=o&&a.push(n));return a}clockwiseCorners(t){let e,r,o,s,n,i,a=t.length;for(i=0;i<a;++i)e=t[i][1].x-t[i][0].x,o=t[i][1].y-t[i][0].y,r=t[i][2].x-t[i][0].x,s=t[i][2].y-t[i][0].y,e*s-o*r<0&&(n=t[i][1],t[i][1]=t[i][3],t[i][3]=n);return t}notTooNear(t,e){let r,o,s,n,i,a,l=[],d=t.length;for(n=0;n<d;++n)for(i=n+1;i<d;++i){for(r=0,a=0;a<4;++a)o=t[n][a].x-t[i][a].x,s=t[n][a].y-t[i][a].y,r+=o*o+s*s;r/4<e*e&&(h.perimeter(t[n])<h.perimeter(t[i])?t[n].tooNear=!0:t[i].tooNear=!0)}for(n=0;n<d;++n)t[n].tooNear||l.push(t[n]);return l}findMarkers(t,e,r){let o,s,n,i=[],a=e.length;for(n=0;n<a;++n)o=e[n],h.warp(t,this.homography,o,r),h.threshold(this.homography,this.homography,h.otsu(this.homography)),s=this.getMarker(this.homography,o),s&&i.push(s);return i}getMarker(t,e){let r,o,s,n,i,a=t.width/7>>>0,d=a*a>>1,c=[],u=[],f=[];for(n=0;n<7;++n)for(s=0===n||6===n?1:6,i=0;i<7;i+=s)if(r={x:i*a,y:n*a,width:a,height:a},h.countNonZero(t,r)>d)return null;for(n=0;n<5;++n)for(c[n]=[],i=0;i<5;++i)r={x:(i+1)*a,y:(n+1)*a,width:a,height:a},c[n][i]=h.countNonZero(t,r)>d?1:0;for(u[0]=c,f[0]=this.hammingDistance(u[0]),o={first:f[0],second:0},n=1;n<4;++n)u[n]=this.rotate(u[n-1]),f[n]=this.hammingDistance(u[n]),f[n]<o.first&&(o.first=f[n],o.second=n);return 0!==o.first?null:new l(this.mat2id(u[o.second]),this.rotate2(e,4-o.second))}hammingDistance(t){let e,r,o,s,n,i=[[1,0,0,0,0],[1,0,1,1,1],[0,1,0,0,1],[0,1,1,1,0]],a=0;for(o=0;o<5;++o){for(r=1/0,s=0;s<4;++s){for(e=0,n=0;n<5;++n)e+=t[o][n]===i[s][n]?0:1;e<r&&(r=e)}a+=r}return a}mat2id(t){let e,r=0;for(e=0;e<5;++e)r<<=1,r|=t[e][1],r<<=1,r|=t[e][3];return r}rotate(t){let e,r,o=[],s=t.length;for(e=0;e<s;++e)for(o[e]=[],r=0;r<t[e].length;++r)o[e][r]=t[t[e].length-r-1][e];return o}rotate2=function(t,e){let r,o=[],s=t.length;for(r=0;r<s;++r)o[r]=t[(e+r)%s];return o}}class c{static svdcmp(t,e,r,o,s){let n,i,a,h,l,d,u,f,x,g,m,y,v,p,w,b=0,M=0,_=0,P=[];for(i=0;i<r;++i){if(u=i+1,P[i]=_*M,M=y=_=0,i<e){for(d=i;d<e;++d)_+=Math.abs(t[d][i]);if(0!==_){for(d=i;d<e;++d)t[d][i]/=_,y+=t[d][i]*t[d][i];for(g=t[i][i],M=-c.sign(Math.sqrt(y),g),m=g*M-y,t[i][i]=g-M,h=u;h<r;++h){for(y=0,d=i;d<e;++d)y+=t[d][i]*t[d][h];for(g=y/m,d=i;d<e;++d)t[d][h]+=g*t[d][i]}for(d=i;d<e;++d)t[d][i]*=_}}if(o[i]=_*M,M=y=_=0,i<e&&i!==r-1){for(d=u;d<r;++d)_+=Math.abs(t[i][d]);if(0!==_){for(d=u;d<r;++d)t[i][d]/=_,y+=t[i][d]*t[i][d];for(g=t[i][u],M=-c.sign(Math.sqrt(y),g),m=g*M-y,t[i][u]=g-M,d=u;d<r;++d)P[d]=t[i][d]/m;for(h=u;h<e;++h){for(y=0,d=u;d<r;++d)y+=t[h][d]*t[i][d];for(d=u;d<r;++d)t[h][d]+=y*P[d]}for(d=u;d<r;++d)t[i][d]*=_}}b=Math.max(b,Math.abs(o[i])+Math.abs(P[i]))}for(i=r-1;i>=0;--i){if(i<r-1){if(0!==M){for(h=u;h<r;++h)s[h][i]=t[i][h]/t[i][u]/M;for(h=u;h<r;++h){for(y=0,d=u;d<r;++d)y+=t[i][d]*s[d][h];for(d=u;d<r;++d)s[d][h]+=y*s[d][i]}}for(h=u;h<r;++h)s[i][h]=s[h][i]=0}s[i][i]=1,M=P[i],u=i}for(i=Math.min(r,e)-1;i>=0;--i){for(u=i+1,M=o[i],h=u;h<r;++h)t[i][h]=0;if(0!==M){for(M=1/M,h=u;h<r;++h){for(y=0,d=u;d<e;++d)y+=t[d][i]*t[d][h];for(g=y/t[i][i]*M,d=i;d<e;++d)t[d][h]+=g*t[d][i]}for(h=i;h<e;++h)t[h][i]*=M}else for(h=i;h<e;++h)t[h][i]=0;++t[i][i]}for(d=r-1;d>=0;--d)for(a=1;a<=30;++a){for(n=!0,u=d;u>=0;--u){if(f=u-1,Math.abs(P[u])+b===b){n=!1;break}if(Math.abs(o[f])+b===b)break}if(n)for(x=0,y=1,i=u;i<=d&&(g=y*P[i],Math.abs(g)+b!==b);++i)for(M=o[i],m=c.pythag(g,M),o[i]=m,m=1/m,x=M*m,y=-g*m,h=0;h<e;++h)p=t[h][f],w=t[h][i],t[h][f]=p*x+w*y,t[h][i]=w*x-p*y;if(w=o[d],u===d){if(w<0)for(o[d]=-w,h=0;h<r;++h)s[h][d]=-s[h][d];break}if(30===a)return!1;for(v=o[u],f=d-1,p=o[f],M=P[f],m=P[d],g=((p-w)*(p+w)+(M-m)*(M+m))/(2*m*p),M=c.pythag(g,1),g=((v-w)*(v+w)+m*(p/(g+c.sign(M,g))-m))/v,x=y=1,h=u;h<=f;++h){for(i=h+1,M=P[i],p=o[i],m=y*M,M*=x,w=c.pythag(g,m),P[h]=w,x=g/w,y=m/w,g=v*x+M*y,M=M*x-v*y,m=p*y,p*=x,l=0;l<r;++l)v=s[l][h],w=s[l][i],s[l][h]=v*x+w*y,s[l][i]=w*x-v*y;for(w=c.pythag(g,m),o[h]=w,0!==w&&(w=1/w,x=g*w,y=m*w),g=x*M+y*p,v=x*p-y*M,l=0;l<e;++l)p=t[l][h],w=t[l][i],t[l][h]=p*x+w*y,t[l][i]=w*x-p*y}P[u]=0,P[d]=g,o[d]=v}return!0}static pythag(t,e){let r,o=Math.abs(t),s=Math.abs(e);return o>s?(r=s/o,o*Math.sqrt(1+r*r)):0===s?0:(r=o/s,s*Math.sqrt(1+r*r))}static sign(t,e){return e>=0?Math.abs(t):-Math.abs(t)}}class u{v;constructor(t,e,r){this.v=[t||0,e||0,r||0]}copy(t){let e=this.v;const r=t.v;return e[0]=r[0],e[1]=r[1],e[2]=r[2],this}static add(t,e){const r=new u,o=r.v,s=t.v,n=e.v;return o[0]=s[0]+n[0],o[1]=s[1]+n[1],o[2]=s[2]+n[2],r}static sub(t,e){const r=new u,o=r.v,s=t.v,n=e.v;return o[0]=s[0]-n[0],o[1]=s[1]-n[1],o[2]=s[2]-n[2],r}static mult(t,e){const r=new u,o=r.v,s=t.v,n=e.v;return o[0]=s[0]*n[0],o[1]=s[1]*n[1],o[2]=s[2]*n[2],r}static addScalar(t,e){const r=new u,o=r.v,s=t.v;return o[0]=s[0]+e,o[1]=s[1]+e,o[2]=s[2]+e,r}static multScalar(t,e){const r=new u,o=r.v,s=t.v;return o[0]=s[0]*e,o[1]=s[1]*e,o[2]=s[2]*e,r}static dot(t,e){const r=t.v,o=e.v;return r[0]*o[0]+r[1]*o[1]+r[2]*o[2]}static cross(t,e){const r=t.v,o=e.v;return new u(r[1]*o[2]-r[2]*o[1],r[2]*o[0]-r[0]*o[2],r[0]*o[1]-r[1]*o[0])}normalize(){const t=this.v,e=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return e>0&&(t[0]/=e,t[1]/=e,t[2]/=e),e}static inverse(t){const e=new u,r=e.v,o=t.v;return 0!==o[0]&&(r[0]=1/o[0]),0!==o[1]&&(r[1]=1/o[1]),0!==o[2]&&(r[2]=1/o[2]),e}square(){const t=this.v;return t[0]*t[0]+t[1]*t[1]+t[2]*t[2]}minIndex(){const t=this.v;return t[0]<t[1]?t[0]<t[2]?0:2:t[1]<t[2]?1:2}}class f{m;constructor(){this.m=[[0,0,0],[0,0,0],[0,0,0]]}static clone(t){const e=new f,r=e.m,o=t.m;return r[0][0]=o[0][0],r[0][1]=o[0][1],r[0][2]=o[0][2],r[1][0]=o[1][0],r[1][1]=o[1][1],r[1][2]=o[1][2],r[2][0]=o[2][0],r[2][1]=o[2][1],r[2][2]=o[2][2],e}copy(t){const e=this.m,r=t.m;return e[0][0]=r[0][0],e[0][1]=r[0][1],e[0][2]=r[0][2],e[1][0]=r[1][0],e[1][1]=r[1][1],e[1][2]=r[1][2],e[2][0]=r[2][0],e[2][1]=r[2][1],e[2][2]=r[2][2],this}static fromRows(t,e,r){const o=new f,s=o.m,n=t.v,i=e.v,a=r.v;return s[0][0]=n[0],s[0][1]=n[1],s[0][2]=n[2],s[1][0]=i[0],s[1][1]=i[1],s[1][2]=i[2],s[2][0]=a[0],s[2][1]=a[1],s[2][2]=a[2],o}static fromDiagonal(t){const e=new f,r=e.m,o=t.v;return r[0][0]=o[0],r[1][1]=o[1],r[2][2]=o[2],e}static transpose(t){const e=new f,r=e.m,o=t.m;return r[0][0]=o[0][0],r[0][1]=o[1][0],r[0][2]=o[2][0],r[1][0]=o[0][1],r[1][1]=o[1][1],r[1][2]=o[2][1],r[2][0]=o[0][2],r[2][1]=o[1][2],r[2][2]=o[2][2],e}static mult(t,e){const r=new f,o=r.m,s=t.m,n=e.m;return o[0][0]=s[0][0]*n[0][0]+s[0][1]*n[1][0]+s[0][2]*n[2][0],o[0][1]=s[0][0]*n[0][1]+s[0][1]*n[1][1]+s[0][2]*n[2][1],o[0][2]=s[0][0]*n[0][2]+s[0][1]*n[1][2]+s[0][2]*n[2][2],o[1][0]=s[1][0]*n[0][0]+s[1][1]*n[1][0]+s[1][2]*n[2][0],o[1][1]=s[1][0]*n[0][1]+s[1][1]*n[1][1]+s[1][2]*n[2][1],o[1][2]=s[1][0]*n[0][2]+s[1][1]*n[1][2]+s[1][2]*n[2][2],o[2][0]=s[2][0]*n[0][0]+s[2][1]*n[1][0]+s[2][2]*n[2][0],o[2][1]=s[2][0]*n[0][1]+s[2][1]*n[1][1]+s[2][2]*n[2][1],o[2][2]=s[2][0]*n[0][2]+s[2][1]*n[1][2]+s[2][2]*n[2][2],r}static multVector(t,e){const r=t.m,o=e.v;return new u(r[0][0]*o[0]+r[0][1]*o[1]+r[0][2]*o[2],r[1][0]*o[0]+r[1][1]*o[1]+r[1][2]*o[2],r[2][0]*o[0]+r[2][1]*o[1]+r[2][2]*o[2])}column(t){const e=this.m;return new u(e[0][t],e[1][t],e[2][t])}row(t){const e=this.m;return new u(e[t][0],e[t][1],e[t][2])}}class x{model;focalLength;modelVectors;modelNormal;modelPseudoInverse;constructor(t,e){this.model=this.buildModel(t),this.focalLength=e,this.init()}buildModel(t){const e=t/2;return[new u(-e,e,0),new u(e,e,0),new u(e,-e,0),new u(-e,-e,0)]}init(){let t,e=new u,r=new f;this.modelVectors=f.fromRows(u.sub(this.model[1],this.model[0]),u.sub(this.model[2],this.model[0]),u.sub(this.model[3],this.model[0])),t=f.clone(this.modelVectors),c.svdcmp(t.m,3,3,e.v,r.m),this.modelPseudoInverse=f.mult(f.mult(r,f.fromDiagonal(u.inverse(e))),f.transpose(t)),this.modelNormal=r.column(e.minIndex())}pose(t){let e,r,o=new u(1,1,1),s=new f,n=new f,i=new u,a=new u;return this.pos(t,o,s,n,i,a),e=this.iterate(t,s,i),r=this.iterate(t,n,a),e<r?new g(e,s.m,i.v,r,n.m,a.v):new g(r,n.m,a.v,e,s.m,i.v)}pos(t,e,r,o,s,n){let i,a,h,l,d,c,x,g,m,y=new u(t[1].x,t[2].x,t[3].x),v=new u(t[1].y,t[2].y,t[3].y),p=u.addScalar(u.mult(y,e),-t[0].x),w=u.addScalar(u.mult(v,e),-t[0].y),b=f.multVector(this.modelPseudoInverse,p),M=f.multVector(this.modelPseudoInverse,w),_=M.square()-b.square(),P=u.dot(b,M),B=0,k=0;0===_?(B=Math.sqrt(Math.abs(2*P)),k=-Math.PI/2*(P<0?-1:P>0?1:0)):(B=Math.sqrt(Math.sqrt(_*_+4*P*P)),k=Math.atan(-2*P/_),_<0&&(k+=Math.PI),k/=2),g=B*Math.cos(k),m=B*Math.sin(k),i=u.add(b,u.multScalar(this.modelNormal,g)),a=u.add(M,u.multScalar(this.modelNormal,m)),l=i.normalize(),d=a.normalize(),h=u.cross(i,a),r.copy(f.fromRows(i,a,h)),c=(l+d)/2,x=f.multVector(r,this.model[0]),s.v=[t[0].x/c-x.v[0],t[0].y/c-x.v[1],this.focalLength/c],i=u.sub(b,u.multScalar(this.modelNormal,g)),a=u.sub(M,u.multScalar(this.modelNormal,m)),l=i.normalize(),d=a.normalize(),h=u.cross(i,a),o.copy(f.fromRows(i,a,h)),c=(l+d)/2,x=f.multVector(o,this.model[0]),n.v=[t[0].x/c-x.v[0],t[0].y/c-x.v[1],this.focalLength/c]}iterate(t,e,r){let o,s,n,i,a=1/0,h=new f,l=new f,d=new u,c=new u,x=0;for(;x<100&&(o=u.addScalar(u.multScalar(f.multVector(this.modelVectors,e.row(2)),1/r.v[2]),1),this.pos(t,o,h,l,d,c),n=this.getError(t,h,d),i=this.getError(t,l,c),n<i?(e.copy(h),r.copy(d),s=n):(e.copy(l),r.copy(c),s=i),!(s<=2||s>a));++x)a=s;return s}getError(t,e,r){let o,s,n,i,a,h,l,d,c,x=u.add(f.multVector(e,this.model[0]),r),g=u.add(f.multVector(e,this.model[1]),r),m=u.add(f.multVector(e,this.model[2]),r),y=u.add(f.multVector(e,this.model[3]),r);return o=[{x:x.v[0]*this.focalLength/x.v[2],y:x.v[1]*this.focalLength/x.v[2]},{x:g.v[0]*this.focalLength/g.v[2],y:g.v[1]*this.focalLength/g.v[2]},{x:m.v[0]*this.focalLength/m.v[2],y:m.v[1]*this.focalLength/m.v[2]},{x:y.v[0]*this.focalLength/y.v[2],y:y.v[1]*this.focalLength/y.v[2]}],s=this.angle(t[0],t[1],t[3]),n=this.angle(t[1],t[2],t[0]),i=this.angle(t[2],t[3],t[1]),a=this.angle(t[3],t[0],t[2]),h=this.angle(o[0],o[1],o[3]),l=this.angle(o[1],o[2],o[0]),d=this.angle(o[2],o[3],o[1]),c=this.angle(o[3],o[0],o[2]),(Math.abs(s-h)+Math.abs(n-l)+Math.abs(i-d)+Math.abs(a-c))/4}angle(t,e,r){const o=e.x-t.x,s=e.y-t.y,n=r.x-t.x,i=r.y-t.y;return 180*Math.acos((o*n+s*i)/(Math.sqrt(o*o+s*s)*Math.sqrt(n*n+i*i)))/Math.PI}}class g{bestError;bestRotation;bestTranslation;alternativeError;alternativeRotation;alternativeTranslation;constructor(t,e,r,o,s,n){this.bestError=t,this.bestRotation=e,this.bestTranslation=r,this.alternativeError=o,this.alternativeRotation=s,this.alternativeTranslation=n}}return function(t){t.Image=i,t.grayscale=h.grayscale,t.threshold=h.threshold,t.adaptiveThreshold=h.adaptiveThreshold,t.otsu=h.otsu,t.stackBoxBlur=h.stackBoxBlur,t.gaussianBlur=h.gaussianBlur,t.findContours=h.findContours,t.approxPolyDP=h.approxPolyDP,t.warp=h.warp,t.getPerspectiveTransform=h.getPerspectiveTransform,t.isContourConvex=h.isContourConvex,t.perimeter=h.perimeter,t.minEdgeLength=h.minEdgeLength,t.countNonZero=h.countNonZero}(t||(t={})),function(t){t.Detector=d}(e||(e={})),function(t){t.svdcmp=c.svdcmp,t.pythag=c.pythag,t.sign=c.sign}(r||(r={})),function(t){t.Pose=g,t.Posit=x}(o||(o={})),n})()));