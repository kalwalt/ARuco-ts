!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r=e();for(var o in r)("object"==typeof exports?exports:t)[o]=r[o]}}(this,(()=>(()=>{"use strict";var t,e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{CV:()=>t});class o{width;height;data;constructor(t,e,r){this.width=t,this.height=e,this.data=r}}class a{color;next;constructor(){this.color=0,this.next=null}}class n{static grayscale(t,e){let r=t.data,o=e.data,a=r.length,n=0,i=0;for(;n<a;n+=4)o[i++]=.299*r[n]+.587*r[n+1]+.114*r[n+2]+.5&255;return new ImageData(o,t.width,t.height)}static threshold(t,e,r){let o,a=t.data,n=e.data,i=a.length,d=[];for(o=0;o<256;++o)d[o]=o<=r?0:255;for(o=0;o<i;++o)n[o]=d[a[o]];return new ImageData(n,t.width,t.height)}static adaptiveThreshold(t,e,r,o){let a,i=t.data,d=e.data,s=i.length,x=[];for(n.stackBoxBlur(t,e,r),a=0;a<768;++a)x[a]=a-255<=-o?255:0;for(a=0;a<s;++a)d[a]=x[i[a]-d[a]+255];return new ImageData(d,t.width,t.height)}static otsu(t){let e,r,o,a=t.data,n=a.length,i=[],d=0,s=0,x=0,h=0,l=0,u=0;for(o=0;o<256;++o)i[o]=0;for(o=0;o<n;++o)i[a[o]]++;for(o=0;o<256;++o)s+=i[o]*o;for(o=0;o<256;++o)if(h+=i[o],0!==h){if(l=n-h,0===l)break;x+=i[o]*o,e=x/h-(s-x)/l,r=h*l*e*e,r>u&&(u=r,d=o)}return d}static stackBoxBlurMult=[1,171,205,293,57,373,79,137,241,27,391,357,41,19,283,265];static stackBoxBlurShift=[0,9,10,11,9,12,10,11,12,9,13,13,10,9,13,13];static stackBoxBlur(t,e,r){let o,i,d,s,x,h,l,u,f,c,g=t.data,y=e.data,p=t.height,_=t.width,w=p-1,b=_-1,m=r+r+1,B=r+1,v=n.stackBoxBlurMult[r],P=n.stackBoxBlurShift[r];for(o=i=new a,c=1;c<m;++c)o=o.next=new a;for(o.next=i,x=0,f=0;f<p;++f){for(h=x,d=g[x],s=B*d,o=i,c=0;c<B;++c)o.color=d,o=o.next;for(c=1;c<B;++c)o.color=g[x+c],s+=o.color,o=o.next;for(o=i,u=0;u<_;++u)y[x++]=s*v>>>P,l=u+B,l=h+(l<b?l:b),s-=o.color-g[l],o.color=g[l],o=o.next}for(u=0;u<_;++u){for(x=u,h=x+_,d=y[x],s=B*d,o=i,c=0;c<B;++c)o.color=d,o=o.next;for(c=1;c<B;++c)o.color=y[h],s+=o.color,o=o.next,h+=_;for(o=i,f=0;f<p;++f)y[x]=s*v>>>P,l=f+B,l=u+(l<w?l:w)*_,s-=o.color-y[l],o.color=y[l],o=o.next,x+=_}return new ImageData(y,t.width,t.height)}static gaussianBlur(t,e,r,o){var a=n.gaussianKernel(o);return e=new ImageData(e.data,t.width,t.height),r=new ImageData(r.data,t.width,t.height),n.gaussianBlurFilter(t,r,a,!0),n.gaussianBlurFilter(r,e,a,!1),e}static gaussianBlurFilter(t,e,r,o){var a,n,i,d,s,x=t.data,h=e.data,l=t.height,u=t.width,f=0,c=r.length>>1;for(i=0;i<l;++i)for(d=0;d<u;++d){for(n=0,s=-c;s<=c;++s)o?(a=f+s,(d+s<0||d+s>=u)&&(a=f)):(a=f+s*u,(i+s<0||i+s>=l)&&(a=f)),n+=r[c+s]*x[a];h[f++]=o?n:n+.5&255}return e}static gaussianKernel(t){let e,r,o,a,n,i,d=[];if(t<=7&&t%2==1)d=[[1],[.25,.5,.25],[.0625,.25,.375,.25,.0625],[.03125,.109375,.21875,.28125,.21875,.109375,.03125]][t>>1];else{for(e=.5*(t-1),r=.8+.3*(e-1),o=-.5/(r*r),a=0,i=0;i<t;++i)n=i-e,a+=d[i]=Math.exp(o*n*n);for(a=1/a,i=0;i<t;++i)d[i]*=a}return d}static findContours(t,e){let r,o,a,i,d,s,x,h,l,u=t.width,f=t.height,c=[];for(r=n.binaryBorder(t,e),o=n.neighborhoodDeltas(u+2),a=u+3,d=1,h=0;h<f;++h,a+=2)for(l=0;l<u;++l,++a)i=r[a],0!==i&&(s=x=!1,1===i&&0===r[a-1]?s=!0:i>=1&&0===r[a+1]&&(x=!0),(s||x)&&(++d,c.push(n.borderFollowing(r,a,d,{x:l,y:h},x,o))));return c}static borderFollowing(t,e,r,o,a,i){let d,s,x,h,l,u,f=[];f.hole=a,h=l=a?0:4;do{if(h=h-1&7,d=e+i[h],0!==t[d])break}while(h!==l);if(h===l)t[e]=-r,f.push({x:o.x,y:o.y});else for(s=e,u=4^h;;){l=h;do{x=s+i[++h]}while(0===t[x]);if(h&=7,h-1>>>0<l>>>0?t[s]=-r:1===t[s]&&(t[s]=r),f.push({x:o.x,y:o.y}),u=h,o.x+=n.neighborhood[h][0],o.y+=n.neighborhood[h][1],x===e&&s===d)break;s=x,h=h+4&7}return f}static neighborhood=[[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[-1,1],[0,1],[1,1]];static neighborhoodDeltas(t){let e=[],r=n.neighborhood.length,o=0;for(;o<r;++o)e[o]=n.neighborhood[o][0]+n.neighborhood[o][1]*t;return e.concat(e)}static approxPolyDP(t,e){let r,o,a,n,i,d,s,x,h,l,u,f={start_index:0,end_index:0},c={start_index:0,end_index:0},g=[],y=[],p=t.length;for(e*=e,u=0,h=0;h<3;++h)for(i=0,u=(u+c.start_index)%p,o=t[u],++u===p&&(u=0),l=1;l<p;++l)r=t[u],++u===p&&(u=0),s=r.x-o.x,x=r.y-o.y,n=s*s+x*x,n>i&&(i=n,c.start_index=l);for(i<=e?g.push({x:o.x,y:o.y}):(f.start_index=u,f.end_index=c.start_index+=f.start_index,c.start_index-=c.start_index>=p?p:0,c.end_index=f.start_index,c.end_index<c.start_index&&(c.end_index+=p),y.push({start_index:c.start_index,end_index:c.end_index}),y.push({start_index:f.start_index,end_index:f.end_index}));0!==y.length;){if(f=y.pop(),a=t[f.end_index%p],o=t[u=f.start_index%p],++u===p&&(u=0),f.end_index<=f.start_index+1)d=!0;else{for(i=0,s=a.x-o.x,x=a.y-o.y,h=f.start_index+1;h<f.end_index;++h)r=t[u],++u===p&&(u=0),n=Math.abs((r.y-o.y)*s-(r.x-o.x)*x),n>i&&(i=n,c.start_index=h);d=i*i<=e*(s*s+x*x)}d?g.push({x:o.x,y:o.y}):(c.end_index=f.end_index,f.end_index=c.start_index,y.push({start_index:c.start_index,end_index:c.end_index}),y.push({start_index:f.start_index,end_index:f.end_index}))}return g}static warp(t,e,r,o){var a,i,d,s,x,h,l,u,f,c,g,y,p,_,w,b,m,B,v,P,k,D,C=t.data,T=e.data,I=t.width,M=t.height,j=0;for(p=(y=n.getPerspectiveTransform(r,o-1))[8],_=y[2],w=y[5],k=0;k<o;++k)for(b=p+=y[7],m=_+=y[1],B=w+=y[4],D=0;D<o;++D)b+=y[6],i=(a=(v=(m+=y[0])/b)>>>0)==I-1?a:a+1,s=1-(d=v-a),l=1-(h=(P=(B+=y[3])/b)-(x=P>>>0)),u=f=x*I,c=g=(x===M-1?x:x+1)*I,T[j++]=l*(s*C[u+a]+d*C[f+i])+h*(s*C[c+a]+d*C[g+i])&255;return new ImageData(T,o,o)}static getPerspectiveTransform(t,e){let r=n.square2quad(t);return r[0]/=e,r[1]/=e,r[3]/=e,r[4]/=e,r[6]/=e,r[7]/=e,r}static square2quad(t){let e,r,o,a,n,i,d,s=[];return e=t[0].x-t[1].x+t[2].x-t[3].x,r=t[0].y-t[1].y+t[2].y-t[3].y,0===e&&0===r?(s[0]=t[1].x-t[0].x,s[1]=t[2].x-t[1].x,s[2]=t[0].x,s[3]=t[1].y-t[0].y,s[4]=t[2].y-t[1].y,s[5]=t[0].y,s[6]=0,s[7]=0,s[8]=1):(o=t[1].x-t[2].x,a=t[3].x-t[2].x,n=t[1].y-t[2].y,i=t[3].y-t[2].y,d=o*i-a*n,s[6]=(e*i-a*r)/d,s[7]=(o*r-e*n)/d,s[8]=1,s[0]=t[1].x-t[0].x+s[6]*t[1].x,s[1]=t[3].x-t[0].x+s[7]*t[3].x,s[2]=t[0].x,s[3]=t[1].y-t[0].y+s[6]*t[1].y,s[4]=t[3].y-t[0].y+s[7]*t[3].y,s[5]=t[0].y),s}static isContourConvex(t){let e,r,o,a,n,i,d,s,x=0,h=!0,l=t.length,u=0,f=0;for(r=t[l-1],e=t[0],n=e.x-r.x,i=e.y-r.y;u<l;++u){if(++f===l&&(f=0),r=e,e=t[f],d=e.x-r.x,s=e.y-r.y,o=d*i,a=s*n,x|=a>o?1:a<o?2:3,3===x){h=!1;break}n=d,i=s}return h}static perimeter(t){let e,r,o=t.length,a=0,n=o-1,i=0;for(;a<o;n=a++)e=t[a].x-t[n].x,r=t[a].y-t[n].y,i+=Math.sqrt(e*e+r*r);return i}static minEdgeLength(t){let e,r,o,a=t.length,n=0,i=a-1,d=1/0;for(;n<a;i=n++)r=t[n].x-t[i].x,o=t[n].y-t[i].y,e=r*r+o*o,e<d&&(d=e);return Math.sqrt(d)}static countNonZero(t,e){let r,o,a=t.data,n=e.height,i=e.width,d=e.x+e.y*t.width,s=t.width-i,x=0;for(r=0;r<n;++r){for(o=0;o<i;++o)0!==a[d++]&&++x;d+=s}return x}static binaryBorder(t,e){let r,o,a=t.data,n=t.height,i=t.width,d=0,s=0;for(o=-2;o<i;++o)e[s++]=0;for(r=0;r<n;++r){for(e[s++]=0,o=0;o<i;++o)e[s++]=0===a[d++]?0:1;e[s++]=0}for(o=-2;o<i;++o)e[s++]=0;return e}}return function(t){t.Image=o,t.grayscale=n.grayscale,t.threshold=n.threshold,t.adaptiveThreshold=n.adaptiveThreshold,t.otsu=n.otsu,t.stackBoxBlur=n.stackBoxBlur,t.gaussianBlur=n.gaussianBlur,t.findContours=n.findContours,t.approxPolyDP=n.approxPolyDP,t.warp=n.warp,t.getPerspectiveTransform=n.getPerspectiveTransform,t.isContourConvex=n.isContourConvex,t.perimeter=n.perimeter,t.minEdgeLength=n.minEdgeLength,t.countNonZero=n.countNonZero}(t||(t={})),r})()));